<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Shooting Game with AI Bots</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden;
    background: #111;
    font-family: Arial, sans-serif;
  }
  canvas {
    background: #222;
    display: block;
    margin: 0 auto;
  }
  #healthBar {
    position: fixed;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    width: 300px;
    height: 20px;
    background: #555;
    border-radius: 10px;
    overflow: hidden;
  }
  #healthFill {
    height: 100%;
    background: limegreen;
    width: 100%;
    transition: width 0.3s ease;
  }
  #gameOver {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #f55;
    font-size: 48px;
    display: none;
  }
</style>
</head>
<body>

<div id="healthBar">
  <div id="healthFill"></div>
</div>
<div id="gameOver">GAME OVER</div>

<canvas id="gameCanvas" width="800" height="600"></canvas>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  const width = canvas.width;
  const height = canvas.height;

  // Player setup
  const player = {
    x: width/2,
    y: height/2,
    size: 20,
    speed: 3.5,
    color: 'cyan',
    health: 100,
    cooldown: 0,
    bullets: []
  };

  // Controls
  const keys = {};

  // Bullets common setup
  const bulletSpeed = 7;
  const bulletSize = 6;

  // Bots setup
  class Bot {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.size = 20;
      this.color = 'orange';
      this.health = 30;
      this.speed = 1.5;
      this.bullets = [];
      this.cooldown = 0;
    }

    moveTowards(targetX, targetY) {
      const dx = targetX - this.x;
      const dy = targetY - this.y;
      const dist = Math.hypot(dx, dy);
      if (dist > 0) {
        this.x += (dx / dist) * this.speed;
        this.y += (dy / dist) * this.speed;
      }
    }

    shootAt(targetX, targetY) {
      if (this.cooldown <= 0) {
        const angle = Math.atan2(targetY - this.y, targetX - this.x);
        this.bullets.push({
          x: this.x,
          y: this.y,
          dx: Math.cos(angle) * bulletSpeed,
          dy: Math.sin(angle) * bulletSpeed,
          size: bulletSize,
          color: 'red'
        });
        this.cooldown = 60; // cooldown frames
      }
    }

    update() {
      this.cooldown--;
      if (this.cooldown < 0) this.cooldown = 0;

      // Move toward player
      this.moveTowards(player.x, player.y);

      // Shoot player if in range
      const dist = Math.hypot(player.x - this.x, player.y - this.y);
      if (dist < 400) this.shootAt(player.x, player.y);

      // Update bullets
      this.bullets = this.bullets.filter(bullet => {
        bullet.x += bullet.dx;
        bullet.y += bullet.dy;
        // Check if bullet hits player
        if (
          bullet.x > player.x - player.size / 2 &&
          bullet.x < player.x + player.size / 2 &&
          bullet.y > player.y - player.size / 2 &&
          bullet.y < player.y + player.size / 2
        ) {
          player.health -= 10;
          updateHealthBar();
          return false; // remove bullet
        }
        // Remove bullet if out of bounds
        return bullet.x >= 0 && bullet.x <= width && bullet.y >= 0 && bullet.y <= height;
      });
    }

    draw() {
      // Bot body
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2);
      ctx.fill();

      // Draw bullets
      this.bullets.forEach(bullet => {
        ctx.fillStyle = bullet.color;
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, bullet.size / 2, 0, Math.PI * 2);
        ctx.fill();
      });
    }
  }

  const bots = [];
  const maxBots = 5;

  // Spawn bots at random edges
  function spawnBot() {
    let x, y;
    const edge = Math.floor(Math.random() * 4);
    switch (edge) {
      case 0: x = 0; y = Math.random() * height; break;
      case 1: x = width; y = Math.random() * height; break;
      case 2: x = Math.random() * width; y = 0; break;
      case 3: x = Math.random() * width; y = height; break;
    }
    bots.push(new Bot(x, y));
  }

  // Player shooting
  function playerShoot(targetX, targetY) {
    if (player.cooldown <= 0) {
      const angle = Math.atan2(targetY - player.y, targetX - player.x);
      player.bullets.push({
        x: player.x,
        y: player.y,
        dx: Math.cos(angle) * bulletSpeed,
        dy: Math.sin(angle) * bulletSpeed,
        size: bulletSize,
        color: 'lime'
      });
      player.cooldown = 15;
    }
  }

  // Player movement update
  function updatePlayer() {
    if (keys['w'] || keys['ArrowUp']) player.y -= player.speed;
    if (keys['s'] || keys['ArrowDown']) player.y += player.speed;
    if (keys['a'] || keys['ArrowLeft']) player.x -= player.speed;
    if (keys['d'] || keys['ArrowRight']) player.x += player.speed;

    // Keep player inside canvas
    player.x = Math.max(player.size/2, Math.min(width - player.size/2, player.x));
    player.y = Math.max(player.size/2, Math.min(height - player.size/2, player.y));

    player.cooldown--;
    if (player.cooldown < 0) player.cooldown = 0;

    // Update player bullets
    player.bullets = player.bullets.filter(bullet => {
      bullet.x += bullet.dx;
      bullet.y += bullet.dy;

      // Check collision with bots
      for (let i = 0; i < bots.length; i++) {
        const bot = bots[i];
        const dist = Math.hypot(bullet.x - bot.x, bullet.y - bot.y);
        if (dist < bot.size / 2) {
          bot.health -= 10;
          if (bot.health <= 0) bots.splice(i, 1);
          return false; // remove bullet
        }
      }

      // Remove bullet if out of bounds
      return bullet.x >= 0 && bullet.x <= width && bullet.y >= 0 && bullet.y <= height;
    });
  }

  // Drawing functions
  function drawPlayer() {
    ctx.fillStyle = player.color;
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.size / 2, 0, Math.PI * 2);
    ctx.fill();

    // Draw player bullets
    player.bullets.forEach(bullet => {
      ctx.fillStyle = bullet.color;
      ctx.beginPath();
      ctx.arc(bullet.x, bullet.y, bullet.size / 2, 0, Math.PI * 2);
      ctx.fill();
    });
  }

  // Health bar update
  function updateHealthBar() {
    const healthFill = document.getElementById('healthFill');
    healthFill.style.width = Math.max(0, player.health) + '%';
  }

  // Game over display
  function gameOver() {
    document.getElementById('gameOver').style.display = 'block';
  }

  // Main game loop
  function gameLoop() {
    ctx.clearRect(0, 0, width, height);

    if (player.health <= 0) {
      gameOver();
      return;
    }

    // Spawn bots over time if less than max
    if (bots.length < maxBots && Math.random() < 0.01) {
      spawnBot();
    }

    updatePlayer();

    bots.forEach(bot => {
      bot.update();
      bot.draw();
    });

    drawPlayer();

    requestAnimationFrame(gameLoop);
  }

  // Input handlers
  window.addEventListener('keydown', (e) => {
    keys[e.key.toLowerCase()] = true;
  });

  window.addEventListener('keyup', (e) => {
    keys[e.key.toLowerCase()] = false;
  });

  canvas.addEventListener('click', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    playerShoot(mouseX, mouseY);
  });

  updateHealthBar();
  gameLoop();
})();
</script>

</body>
</html>





